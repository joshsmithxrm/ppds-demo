# Plugin Components Reference

Technical reference for Plugin Assemblies (classic) and Plugin Packages (modern) in Power Platform solutions. These are fundamentally different component types with distinct build outputs, solution structures, and CI/CD handling requirements.

---

## Quick Comparison

| Aspect | Plugin Assembly | Plugin Package |
|--------|----------------|----------------|
| **Type** | Classic .NET DLL | NuGet package (.nupkg) |
| **Use Case** | Simple plugins, no external deps | Plugins needing NuGet dependencies |
| **Solution Folder** | `PluginAssemblies/` | `pluginpackages/` |
| **Subfolder Pattern** | `{NameNoDots}-{GUID}` | `{prefix}_{PackageName}` |
| **File Location** | Direct in subfolder | In `/package/` child folder |
| **Naming Transform** | Remove dots from name | Add prefix, remove version |
| **Metadata File** | `.dll.data.xml` | `pluginpackage.xml` |
| **CI/CD Action** | `copy-plugin-assemblies` | `copy-plugin-packages` |

---

## Plugin Assemblies (Classic)

Traditional plugin deployment model. Single DLL containing all plugin code.

### Build Output

```
src/Plugins/PPDSDemo.Plugins/bin/Release/net462/
└── PPDSDemo.Plugins.dll        ← Build output
```

### Solution Structure

```
PluginAssemblies/
└── PPDSDemoPlugins-8CA259E1-D1D7-F011-8543-000D3A3B9CBA/
    ├── PPDSDemoPlugins.dll              ← Plugin binary
    └── PPDSDemoPlugins.dll.data.xml     ← Registration metadata
```

### Naming Transformation

**Rule:** Remove all dots from the assembly name (except `.dll` extension).

```
Build Output                    Solution Expects
─────────────────────────────────────────────────
PPDSDemo.Plugins.dll      →     PPDSDemoPlugins.dll
    ↑                               ↑
  dots in name                  dots removed
```

### Subfolder Naming

Pattern: `{AssemblyNameNoDots}-{PluginAssemblyGUID}`

- `PPDSDemo.Plugins` → `PPDSDemoPlugins`
- GUID comes from Dataverse registration (stable per environment)
- Example: `PPDSDemoPlugins-8CA259E1-D1D7-F011-8543-000D3A3B9CBA`

### CI/CD Copy Logic

```bash
# 1. Find target folder by pattern
find PluginAssemblies/ -type d -name "PPDSDemoPlugins-*"

# 2. Copy with transformed name
cp PPDSDemo.Plugins.dll → {folder}/PPDSDemoPlugins.dll
```

---

## Plugin Packages (Modern)

NuGet-based deployment model supporting dependent assemblies. Enables use of external NuGet packages (e.g., Newtonsoft.Json) in plugins.

### Build Output

```
src/PluginPackages/PPDSDemo.PluginPackage/bin/Release/
└── PPDSDemo.PluginPackage.1.0.0.nupkg   ← Build output (includes version)
```

### Solution Structure

```
pluginpackages/                              ← lowercase!
└── ppds_PPDSDemo.PluginPackage/
    ├── pluginpackage.xml                    ← Registration metadata
    └── package/
        └── ppds_PPDSDemo.PluginPackage.nupkg   ← Package binary
```

### Naming Transformation

**Rule:** Add publisher prefix, remove version from filename.

```
Build Output                              Solution Expects
────────────────────────────────────────────────────────────────
PPDSDemo.PluginPackage.1.0.0.nupkg   →   ppds_PPDSDemo.PluginPackage.nupkg
        ↑              ↑                   ↑              ↑
   package name    version            prefix added   version removed
```

### Subfolder Naming

Pattern: `{PublisherPrefix}_{PackageName}`

- Publisher prefix from solution (e.g., `ppds`)
- No GUID - uses the unique name directly
- Example: `ppds_PPDSDemo.PluginPackage`

### Metadata File

The `pluginpackage.xml` contains registration info:

```xml
<pluginpackage uniquename="ppds_PPDSDemo.PluginPackage">
  <version>1.0.0</version>
  <package mimetype="application/octet-stream">ppds_PPDSDemo.PluginPackage.nupkg</package>
</pluginpackage>
```

**Important:** Never overwrite `pluginpackage.xml` - it's generated by export and contains Dataverse registration state.

### CI/CD Copy Logic

```bash
# 1. Extract package ID from build output (strip version)
# PPDSDemo.PluginPackage.1.0.0.nupkg → PPDSDemo.PluginPackage

# 2. Find target folder containing package ID
find pluginpackages/ -type d -name "*_PPDSDemo.PluginPackage"

# 3. Derive target filename from folder name
# ppds_PPDSDemo.PluginPackage → ppds_PPDSDemo.PluginPackage.nupkg

# 4. Copy to package/ subfolder
cp PPDSDemo.PluginPackage.1.0.0.nupkg → {folder}/package/ppds_PPDSDemo.PluginPackage.nupkg
```

---

## Why Two Separate CI/CD Actions?

The differences are significant enough that a single generic action would be complex and error-prone:

| Dimension | Assembly Action | Package Action |
|-----------|-----------------|----------------|
| **Pattern matching** | `{NameNoDots}-*` | `*_{PackageName}` |
| **Target depth** | 1 level | 2 levels (`/package/`) |
| **Name derivation** | `tr -d '.'` | Regex strip version + use folder name |
| **Folder case** | PascalCase | lowercase |

**Single Responsibility Principle:** Each action does one thing well, is easier to test, and can evolve independently.

---

## Common Pitfalls

### Plugin Assemblies

| Pitfall | Solution |
|---------|----------|
| Copying with dots in name | Use `tr -d '.'` transform |
| Wrong GUID folder | Match by name pattern, not hardcoded GUID |
| Missing `.data.xml` | Don't delete - contains step registrations |

### Plugin Packages

| Pitfall | Solution |
|---------|----------|
| Including version in filename | Strip `.X.Y.Z` before `.nupkg` |
| Wrong folder case | Use `pluginpackages/` (lowercase) |
| Copying to wrong depth | Target is `{folder}/package/`, not `{folder}/` |
| Overwriting `pluginpackage.xml` | Only copy `.nupkg`, never metadata |

---

## Version Handling

| Component | Version Location | In Filename? |
|-----------|------------------|--------------|
| Assembly | `.dll.data.xml` `<IntroducedVersion>` | No |
| Package | `pluginpackage.xml` `<version>` | Build: Yes, Solution: No |

For Plugin Packages, the version is tracked in metadata, not the filename. The build outputs `Package.1.0.0.nupkg` but the solution expects `Package.nupkg`.

---

## See Also

- [Pipeline Strategy](../strategy/PIPELINE_STRATEGY.md) - CI/CD pipeline design decisions
- [PAC CLI Reference](./PAC_CLI_REFERENCE.md) - Power Platform CLI commands
- [ALM Overview](../strategy/ALM_OVERVIEW.md) - Application lifecycle management approach
